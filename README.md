# halstead租赁系统

启动虚拟机server01，启动移动端后台和管理端后台

`systemctl start lease-app`

`systemctl start lease-admin`

启动虚拟机server02，检查nginx是否正常启动

`systemctl status nginx`

由于本机以及完成了域名映射，我们可以直接访问以下url

移动端 http://lease.atguigu.com

管理端 http://admin.lease.atguigu.com

----

Linux系统使用、虚拟机配置、MobaXterm远程SSH访问、NAT内网配置

MyBatispuls、Minio、Redis连接、Knife4j案例项目

最终会部署2台虚拟机，本机使用NAT对项目进行连接，静态的前端内容和Nginx服务会部署在一台linux虚拟机上，而后端的Spring项目（移动端后台和管理类端后台）会部署在另一台虚拟机。



该项目为单体项目，个人认为最大的难点是该项目的后台涉及到的数据库SQL查询逻辑十分的复杂，

由于其数据表结构具有相当庞大的关联系统，每个租赁单位涉及到非常多的attribute，所以在写Mybatisplus自定义mapper时，需要配置复杂的query语句以及应用resultMap来映射复杂的返回结果（嵌套结果映射）。



本项目中同样使用了**ThreadLocal**存储用户信息，此处给出详细的解释：

由于加入了JWT自定义拦截器，所以系统的所有操作都会涉及到一次JWT校验功能，同时在本项目中用户的信息是整合到JWT的Payload当中并使用HS256算法加密，所以从JWT中就可以提取出用户的UserId。

在项目中controller中有部分接口会返回用户的信息给前端，那如果直接使用JWT解密操作就会很low，因为这样的话就会在拦截器解密一次，然后再次在controller中解密一次，是对系统资源的浪费。所以对于所有的需要调用用户信息的接口，统一在拦截器部分的JWT校验结束后，就将从JWT解密出来的用户信息以键值对的形式存储在ThreadLocal当中，如果项目中有调用用户信息的接口，则直接从ThreadLocal当中读取信息。



# 简历准备

技术栈：（Vue+H5移动端）双前端，SpringBoot+MyBatisPlus，MySQL+Redis+MINIO

* 灵活应用MybatisPlus嵌套查询和嵌套结果映射来满足复杂的多表查询和分页查询需求
* 注册自定义ConverterFactory映射前端请求，实现项目中的全部枚举类的自动构造
* 配置@Schedule定时任务功能，实现定时检查租约状态功能以及数据库的主动刷新
* 应用MD5算法+EasyCaptcha验证码+JWT自定义拦截器方案实现登录校验与操作授权
* 接入阿里云短信服务，实现移动端验证码登录功能，并设置Key过期时间与限制发送频率
* 调用@Async异步支持，实现异步后台保存用户浏览记录以减少接口响应时间
* 使用延迟删除+主动更新的缓存优化方案，将核心业务接口的平均响应时间从39ms降低至5ms
* 使用Nginx作为静态资源http服务器，部署后端服务的反向代理和负载均衡





# 自圆其说

**》技术栈解释**

主要解释关于MINIO对象存储服务的部署和调用

在我的项目中MINIO被部署在后端所在的虚拟机当中，使用`systemctl minio`来查看状态，我已经将MINIO服务设置为了开机自启

在我的项目中，服务端有一个上传图片的接口，上传MultipartFile格式的数据，然后后端调用MINIO服务后，返回一个url，这个url会返回保存到前端的提交表单中，MySQL数据库中是不会保存图片的，而是图片在MINIO的url

具体来讲的操作逻辑就是，

构建一个MinioClient对象，然后传入`endpoint`、`accessKey`、`secretKey`来配置Client

然后调用`makebucket`方法在客户端创建一个存储桶，然后再调用上传文件到存储桶中

在我的项目中，我把Minio的服务交给了Spring IOC容器进行管理，并在需要使用的时候使用@Autowire进行依赖注入 （在配置类中使用@Bean注解的方法生成）



**》嵌套查询和嵌套结果映射**

这里使用分页查询房间列表的接口来解释

在表设计的时候，一个公寓会包含很多个房间，不同房间可能会有不同的配套和价位，所以这里需要单独一张表

然后公寓所属于公寓的信息也会需要用一张表，记录公寓本身的省市区地理位置，公寓的配套（健身房之类的）

这些所有的标签都是可以编辑的，一个公寓/房间可以维护很多的标签，这些标签也可以进行批量管理，那么也就需要使用标签信息表来管理所有的标签，同时将公寓/房间表里关联标签信息表

用户在H5移动端的登录是有信息的，那么需要用户信息表来存储用户相关的登录信息，头像id等

如果用户和管理人员签订租约，那么用户表会关联租约信息表，同时租约信息表也会关联公寓信息表

所以这个项目作为一个单体项目会用到大量的嵌套查询和多表查询，可以说是持久层非常复杂的单体项目



**这里用一个接口案例来解释嵌套查询/嵌套结果映射：**

假设说我现在用户在H5移动端想要租一个房间，然后他在前端输入省市区地理信息、按照价格排序

这个接口需要返回所有价格房间的分页查询结果

返回给前端的VO包含房间id、房间号、租金（这三个是属于公寓-房间表里）

还有房间所属的公寓信息、公寓图片、公寓配套信息（这三个是属于公寓信息表里的）

公寓所属的标签需要从标签信息表中提取

这里返回的RoomVO里面包含各种类型的数据，房间图片列表的类型是List<GraphVO>

标签列表的类型是List<LabelInfo>，这些都要被一次SQL查询得到

所以我们使用ResultMap来接收查询的结果，完成自动封装VO的作用，这时MyBatisPlus提供的功能

这个功能就是嵌套结果映射



**使用MyBatisPlus的分页插件的时候，只能使用嵌套查询：**

使用嵌套结果映射的时候，只要写一条涉及多表join的select语句，便可以完成VO的自动映射

而嵌套查询呢，是在resultMap里加入select属性的方式来运行子查询，也就是一个resultMap同时运行好几条SQL语句。

这时MyBatis会先执行主查询，然后对于主查询得到的每一个结果在分别进行一次子查询，这样会有性能损失，查询数据库的次数会从1次变成n+1次（n为主查询的结果）

嵌套结果映射的性能毫无疑问是优于嵌套查询的，但是使用分页插件的时候，必须使用嵌套查询

比如我现在使用分页插件，每页返回2个房间，现在数据库里查到了2个房间limit2，但是由于嵌套结果映射的select语句left join了房间图片表，这个房间有2个图片，那么在数据库里这个left join的表就会是2行结果，这时分页插件就会判断这个对象占用了2个空间，这样返回的VO每页就只有一个房间了





**》ConverterFactory对全部枚举类的自动构造**

前端传递给后端的HTTP请求参数会被SpringMVC的WebDataBinder组件绑定到Controller方法的参数上，同时实现参数的绑定；后端响应给前端的数据也会由HTTPMessageConverter来进行类型转换，响应给前端

同时数据库的数据和后端的数据是由MyBatisPlus的TypeHandler组件来完成类型转换

由于在Spring中，我们有一些用枚举类存储的数据，所以我们需要分别配置MyBatisPlus和SpringMVC来保证Integer和枚举类的相互转换

这里以租赁状态为例子，LeaseStatus枚举类，1签约待确认，2已签约，3已取消。。

* 其中SpringMVC的WebDataBinder通过Converter实现自动类型转换，这里的Converter默认在转化枚举类时根据枚举类的实例名称进行转换
* 可以在config包里实现Converter接口的方式，并@Override重载convert方法来实现具体转换
* 所有枚举类都有`.values()`方法获取所有的枚举类，然后遍历所有的枚举类并与传入的参数做对比即可匹配
* 最后在实现WebMvcConfigurer的配置类注册这个自定义的Converter即可

**但是按照上述流程，岂不是要对所有的枚举类型都要去单独写一个Converter？**

Spring有一个接口ConverterFactory

官方文档中这么描述

When you need to centralize the conversion logic for an entire class hierachy

* 创建一个类实现ConverterFactory，传入泛型输入String，输出枚举类的父类BaseEnum
* 其他的转化逻辑和Converter完全相同
* 最后实现WebMvcCongurer并注册自定义的ConverterFactory





**》@Schedule定时任务功能实现数据库的主动刷新**

* 这个实现起来很简单，我创建了一个类来封装所有的定时任务方法，然后在这个类上加上@Component使得他能够被Spring容器扫描到

* 在对应的方法上加上@Schedule的注解，加入了该注解的方法就会在Spring后端运行的时候随着时间自动定期执行
* 其中涉及到cron表达式，这里给一下cron表达式的解析

我用的是`@Schedule(cron = "0 0 0 * * *")`，也就是在每天的0秒0分0时执行一次

检查租约过期状态，自动将已经过期的租约对应的状态进行修改



**》登录校验**

先说一下常用的认证方案，基于Session和基于Token的两种认证

**基于Session：**用户传入用户名密码，后端创建Session返回SessionID给前端

前端存储SessionID在Cookie当中，后续请求全部携带SessionID实现校验

这样的方式如果在高并发访问量很大的时候，会存储大量的Session就会导致压力巨大，后期必须要使用集群来进行压力分担，但是使用了集群之后又会有登录状态共享的问题

**基于Token：**相当于发门票，将用户登录的信息全部封装在门票中，而不是存储在服务端

接下来介绍一下JWT（Java Web Token）的底层：

JWT是一个字符串，由三部分组成头部Header、负载payload、签名signature

【头部】是一个JSON对象经过base64Url编码得到（为了方便将该参数在Url中传递）

包含JWT类型、签名算法等metadata

【负载】也被称为claims，可以在里面封装键值对存储数据（存一些不然没法和Session区分）

里面还存储了非常重要的token过期时间

【签名】是将头部、负载和秘钥经过Header指定的签名算法计算得到的字符串，防止消息被篡改

 

**登录流程整体**

* 用户调用接口请求图形验证码
* 后端的Captcha模块随机生成一个验证码图片，生成一个UUID为key，对应的实际值为value，调用stringRedisTemplate将键值对存储到Redis中，并设置过期时间；同时，将验证码图片通过base64算法序列化后，和UUIDkey一起返回给前端
* 用户填写验证码，发送key和value给后端，后端调用redis进行对照，如果正确，则校验用户名和密码，如果用户名和密码正确，则返回JWT给前端，并将用户名和用户Id封装在JWT的负载里

那么MD5算法在哪里使用的呢？

因为数据库不能明文的保存用户的密码，所以使用单向MD5加密算法来保存用户的密码在数据库·中，每次比对都通过相同的加密方式，并比较加密后的字符串即可



**》阿里云短信服务**

这个也是非常简单的，和Minio一样，在写一个配置类并且将其配置为Bean交给Spring IOC容器管理，然后在使用的时候调用注入依赖即可



**》@Async异步支持**

为浏览历史写一个service，并且在用户分页查询房间列表的时候调用保存方法，在方法上加上该注解即可





**》延迟删除和主动更新方案**

我为这个项目最核心的一个接口设计了Redis缓存模型

也就是在租房的时候查看一个具体的房间里的所有信息，一个房间里的所有信息会包含

图片、租期、配套、标签、支付方式、公寓信息、杂费信息等等，如果每次调用这个接口，都会运行10次左右的SQL（如果直接从数据库查询的话），

这里使用RedisTemplate将RoomDetailVO直接序列化到Redis当中，每次查询的时候先查Redis，查不到了再查数据库。也就是Redis缓存一致性模型的最常见方案

主动更新方案就是在调用SaveOrUpdate/Delete方法时删除缓存，

延迟双删就是等60s后再删一次，防止并发情况下的脏写



